Tabby's Date — Solution Writeup (Notepad Autosave Forensics)
============================================================

Scope
-----
We received an extracted Windows user-profile export. The challenge text suggested
Tabby typed the date details into a note she "didn't think she saved". Modern Windows
Notepad can autosave open tabs, storing state files under its package LocalState/TabState.
Those small blobs are commonly UTF-16LE text with a simple header.

Objective
---------
Recover the unsaved note with WHEN and WHERE of the date.

Conservative, Read-Only Workflow
--------------------------------
All actions below are non-destructive and operate on local files only.

1) Enumerate candidate blobs and do quick triage
   Rationale: get size/mtime/hash and confirm structure via a tiny hexdump + strings preview.

   Command:
     find . -type f -name "*.bin" -print0 | while IFS= read -r -d "" f; do
       echo "===== $f ====="
       stat -c "size=%s  mtime=%y" "$f"
       sha256sum "$f" | awk '{print "sha256=" $1}'
       file "$f"
       xxd -l 128 -g 1 "$f" | sed -n "1,8p"
       echo "--- strings (first 60 lines, len≥6) ---"
       strings -n 6 "$f" | head -n 60
       echo
     done

   Notes:
   • The header began with bytes "4E 50 00 00" and the body displayed UTF-16LE pairs (e.g., 44 00 61 00 74 00 65 00).
   • Entries looked like short notes: chores, study plans, reminders, etc.

2) Extract UTF-16LE strings and grep for “date-ish” indicators
   Rationale: Notepad stores text as UTF-16LE, so use `strings -el`. Keywords target meeting details.

   Command:
     for f in *.bin; do
       echo "===== $f ====="
       strings -el "$f" | grep -niE \
         "date|when|where|meet|pm|am|sat|sun|mon|tue|wed|thu|fri|coffee|cafe|starbucks|address" \
         | head -n 40
       echo
     done

   Key Hit (as observed):
     ===== 2e0dd6b6-ba93-4efc-9fd4-985dad74869a.bin =====
     1: Date with Eric!!!
     6: - when: saturday, sept 14th, 7:00pm
     7: - where: Starbucks on Main Street

   Interpretation:
   • This blob clearly contains the unsaved date details.

3) Dump the entire readable content from the target blob
   Rationale: Produce a clean, complete recovery of the note.

   Command:
     f="2e0dd6b6-ba93-4efc-9fd4-985dad74869a.bin"; echo "FILE: $f"; \
     xxd -l 64 -g 1 "$f"; echo "--- UTF-16LE strings ---"; strings -el "$f"

   Clean Output (UTF-16LE strings):
     Date with Eric!!!
     - when: saturday, sept 14th, 7:00pm
     - where: Starbucks on Main Street
     (i'm sooo excited...)

Result
------
• When: Saturday, Sept 14th, 7:00 PM
• Where: Starbucks on Main Street

Flag
----
flag{165d19b610c02b283fc1a6b4a54c4a58}

Why this works
--------------
• Notepad autosave "TabState" blobs are small, plaintext-ish containers; their body is UTF-16LE.
• `strings -el` is crucial to render the text properly; ASCII-only `strings` misses it.
• Minimal hexdumps confirm structure and that we are not mis-parsing binary.

Provenance Tips
---------------
• Record hashes (sha256) and mtimes during triage for repeatability.
• Keep steps read-only to preserve evidence integrity.


=======================================================

Step 1:  Since there were a lot of binaries:
bash -lc 'find . -type f -name "*.bin" -print0 | while IFS= read -r -d "" f; do echo "===== $f ====="; stat -c "size=%s  mtime=%y" "$f"; sha256sum "$f" | awk "{print \"sha256=\"\$1}"; file "$f"; xxd -l 128 -g 1 "$f" | sed -n "1,8p"; echo "--- strings (first 60 lines, len≥6) ---"; strings -n 6 "$f" | head -n 60; echo; done'

Step 2:  Was to look for a date or some reference to that, which led to getting 'date' 'Eric' etc.
bash -lc 'shopt -s nullglob; for f in *.bin; do echo "===== $f ====="; strings -el "$f" | grep -niE "date|with eric|meet|when|where|time|pm|am|tonight|sat|sun|mon|tue|wed|thu|fri|coffee|cafe|restaurant|address" | head -n 40; echo; done'

Step 3:  Since there was one specific binary file that mentioned the date, we then read thoroughly for the flag:
bash -lc 'f="2e0dd6b6-ba93-4efc-9fd4-985dad74869a.bin"; echo "FILE: $f"; xxd -l 64 -g 1 "$f"; echo "--- UTF-16LE strings ---"; strings -el "$f"'

And that is how to solve this challenge very quickly next time!